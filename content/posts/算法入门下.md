---
title: "算法入门下"
date: 2020-02-06T22:33:46+08:00
draft: false
---

## 选择排序(续)

### 重写 minIndex

循环思路：

```
let minIndex = (numbers) => {
    let index = 0
    for(let i = 1;i < numbers.length; i++){
        if(numbers[i] < numbers[index]){
            index = 1
        }
    }
    return index
}
```

### 重写 sort

```
let sort = (numbers) => {
    for(let i=0;i<numbers.length - 1;i++){
    console.log(`----`)
    console.log(`i: ${i}`)
    let index = minIndex(numbers.slice(i)) + i
    //若循环已经找到第一个最小的数字，则之后再找最小时，忽略第一个
    console.log(`index: ${index}`)
    console.log(`min: ${numbers[index]}`)
    if(index!==i){
    swap(number,index,i)
    console.log(`swap ${index}: ${i}`)
    console.log(numbers)
    }
  }
  return numbers
}

let minIndex = (numbers) => {
    let index = 0
    for(let i = 1;i < numbers.length; i++){
        if(numbers[i] < numbers[index]){
            index = 1
        }
    }
    return index
}

let swap = (array, i, j) => {
    let temp = array[i]
    array[i] = array[j]
    array[j] = temp
}//array为对象，传参复制地址
```

## 快速排序

递归思路：

```
let quickSort = arr => {
    if(arr.length <= 1){ return arr }
    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex, 1)[0]
    let left = []
    let right = []
    for (let i =0;i < arr.length; i++){
        if  (arr[i] < pivot){
            left.push(arr[i])
        } else {
            right.push(arr[i])
        }
    }
    return quickSort(left).concat([povit],quickSort(right) )
}
```

## 归并排序

```
let mergeSort = arr =>{
  let k = arr.length
  if(k===1){return arr}
  let left = arr.slice(0, Math.floor(k/2))
  let right = arr.slice(Math.floor(k/2))
  return merge(mergeSort(left), mergeSort(right))
}
let merge = (a, b) => {
  if(a.length === 0) return b
  if(b.length === 0) return a
  return a[0] > b[0] ?
     [b[0]].concat(merge(a, b.slice(1))) :
     [a[0]].concat(merge(a.slice(1), b))
}
```

## 计数排序

```
let countSort = arr =>{
  let hashTable = {}, max = 0, result = []
  for(let i=0; i<arr.length; i++){ // 遍历数组
    if(!(arr[i] in hashTable)){
      hashTable[arr[i]] = 1
    }else{
      hashTable[arr[i]] += 1
    }
    if(arr[i] > max) {max = arr[i]}
  }
  for(let j=0; j<=max; j++){ // 遍历哈希表
    if(j in hashTable){
      for(let i = 0; i<hashTable[j]; i++){
        result.push(j)
      }
    }
  }
  return result
}

```
